//// Code generated by parrot. DO NOT EDIT.
////

import gleam/dynamic/decode
import gleam/option.{type Option}
import gleam/time/timestamp.{type Timestamp}
import parrot/dev

pub type GetTodo {
  GetTodo(id: Int, title: String, status: String, created_at: String)
}

pub fn get_todo(id id: Int) {
  let sql =
    "SELECT id, title, status, created_at FROM todos
WHERE id = ? LIMIT 1"
  #(sql, [dev.ParamInt(id)], get_todo_decoder())
}

pub fn get_todo_decoder() -> decode.Decoder(GetTodo) {
  use id <- decode.field(0, decode.int)
  use title <- decode.field(1, decode.string)
  use status <- decode.field(2, decode.string)
  use created_at <- decode.field(3, decode.string)
  decode.success(GetTodo(id:, title:, status:, created_at:))
}

pub type ListTodos {
  ListTodos(id: Int, title: String, status: String, created_at: String)
}

pub fn list_todos() {
  let sql =
    "SELECT id, title, status, created_at FROM todos
ORDER BY created_at DESC"
  #(sql, [], list_todos_decoder())
}

pub fn list_todos_decoder() -> decode.Decoder(ListTodos) {
  use id <- decode.field(0, decode.int)
  use title <- decode.field(1, decode.string)
  use status <- decode.field(2, decode.string)
  use created_at <- decode.field(3, decode.string)
  decode.success(ListTodos(id:, title:, status:, created_at:))
}

pub type CreateTodo {
  CreateTodo(
    id: Int,
    title: String,
    status: Option(String),
    created_at: Option(Timestamp),
  )
}

pub fn create_todo(
  id id: Int,
  title title: String,
  status status: Option(String),
) {
  let sql =
    "INSERT INTO todos (
  id, title, status
) VALUES (
  ?, ?, ?
)
RETURNING id, title, status, created_at"
  #(
    sql,
    [
      dev.ParamInt(id),
      dev.ParamString(title),
      dev.ParamNullable(option.map(status, fn(v) { dev.ParamString(v) })),
    ],
    create_todo_decoder(),
  )
}

pub fn create_todo_decoder() -> decode.Decoder(CreateTodo) {
  use id <- decode.field(0, decode.int)
  use title <- decode.field(1, decode.string)
  use status <- decode.field(2, decode.optional(decode.string))
  use created_at <- decode.field(3, decode.optional(dev.datetime_decoder()))
  decode.success(CreateTodo(id:, title:, status:, created_at:))
}

pub type UpdateTodo {
  UpdateTodo(
    id: Int,
    title: String,
    status: Option(String),
    created_at: Option(Timestamp),
  )
}

pub fn update_todo(
  title title: String,
  status status: Option(String),
  id id: Int,
) {
  let sql =
    "UPDATE todos
SET title = ?, status = ?
WHERE id = ?
RETURNING id, title, status, created_at"
  #(
    sql,
    [
      dev.ParamString(title),
      dev.ParamNullable(option.map(status, fn(v) { dev.ParamString(v) })),
      dev.ParamInt(id),
    ],
    update_todo_decoder(),
  )
}

pub fn update_todo_decoder() -> decode.Decoder(UpdateTodo) {
  use id <- decode.field(0, decode.int)
  use title <- decode.field(1, decode.string)
  use status <- decode.field(2, decode.optional(decode.string))
  use created_at <- decode.field(3, decode.optional(dev.datetime_decoder()))
  decode.success(UpdateTodo(id:, title:, status:, created_at:))
}

pub fn delete_todo(id id: Int) {
  let sql =
    "DELETE FROM todos
WHERE id = ?"
  #(sql, [dev.ParamInt(id)])
}
